<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="">
		<meta name="author" content="Michael Grijalva">

		<link rel="shortcut icon" href="favicon.ico">

		<title>Projects</title>

		<link href="css/bootstrap.min.css" rel="stylesheet">
		<link href="custom-style.css" rel="stylesheet">
	</head>
	<body>

		<div class="navbar navbar-inverse navbar-fixed-top custom-navbar" role="navigation">
			<div class="container">
				<div class="navbar-header">
					<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
						<span class="sr-only">Toggle Navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
					<a class="navbar-brand" href="index.html">***</a>
				</div>
				<div class="collapse navbar-collapse">
					<ul class="nav navbar-nav">
						<li><a href="index.html">Home</a></li>
<li class="active"><a href="projects.html">Projects</a></li>						<li><a href="experiments.html">Experiments</a></li>
					</ul>
				</div>
			</div>
		</div>

		<div class="container">
			<div class="content-main">
<h1 class="page-title">Projects</h1><hr/><p>Here you will find a collection of my work. Class projects, games, experiments, etc. All files on this page are distributed via my Dropbox or Github page. Click the images for an enlarged view.</p><h2>Open Source Contributions</h2><!-- Cultural Heritage project --><table class="table table-bordered table-custom"><thead><tr><th>Sphere Recognition for CHI</th><th><a target="_blank" href="https://github.com/CMPS119-F/RTI_Pattern">Github Page</a></th></tr></thead><tbody><tr><td><p>At UCSC I took a class where non-profit organizations proposed projects for the class. We formed teams, and I worked on a 3 person team on a project for <a target="_blank" href="http://culturalheritageimaging.org/">Cultural Heritage Imaging's</a> (CHI) RTIBuilder software.<br/><br/>In RTIBuilder, once the user has loaded their images, they must highlight the area that contains a special sphere. Our job was to automate this step. We used a special pattern that our software will recognize in order to locate the sphere. Visit CHI's website for more details on what a RTI image is.<br/><br/>See the Github page for downloads, technical details, and more. We used:<ul><li>C</li><li>ARToolkit (pattern recognition)</li><li>SDL2 (loading images)</li></ul></p></td><td><a href="images/RTI_image.png"><img width="200px" src="images/RTI_image.png"/></a></td></tr></tbody></table><h2>Apps</h2><!-- Particle playground --><table class="table table-bordered table-custom"><thead><tr><th>Particle Playground</th><th><a target="_blank" href="http://www.windowsphone.com/en-us/store/app/particle-playground/2f0f3697-9557-4e67-8c76-d68cad5724a1"><img src="images/wp_download.png" /></a></th></tr></thead><tbody><tr><td><p>This app is an interactive particle simulation with sounds to complement. You drag your fingers across the screen (or tap) to create particles. You can customize the speed and color of the particles. This is meant to simply be a calm simulation to play with.</p><ul><li>Runs on Windows Phone 8</li><li>Built with Monogame and Visual Studio 2012</li><li>Added 10/17/2013</li></ul></td><td><a href="images/part_playground.png"><img width="200px" src="images/part_playground.png"/></a></td></tr></tbody></table><h2>Desktop Programs</h2><!-- Car Maintenance Tracker --><table class="table table-bordered table-custom"><thead><tr><th>Car Maintenance Tracker</th><th><a href="https://github.com/mgrijalva/Car_Maintenance_Tracker/releases">Download</a><br/><a href="https://bitbucket.org/mgrijalva/car-maintenance-tracker">Source Code</a></th></tr></thead><tbody><tr><td><p>This little program allows you to keep track of car maintenance. You enter when you last changed the listed items as well as how often they should be changed. The next time you should perform the maintenance is listed at the right. You can save a file containing the data.<br/><br/>Requires .NET framework to run.<br/><br/>This program was orginally written in C, but it has been converted to C# with a GUI.</p></td><td><a href="images/car_maintenance_tracker.png"><img width="200px" src="images/car_maintenance_tracker.png"/></a></td></tr></tbody></table><h2>Class Projects</h2><!-- Film clouds --><table id="filmclouds" class="table table-bordered table-custom"><thead><tr><th>Film Clouds (Python, D3)</th><th><a href="https://github.com/mgrijalva/Film-Clouds">Github repo</a><br/><a href="filmclouds/index.html">Live Demo</a><br/><a href="http://classes.soe.ucsc.edu/cmps161/Winter14/projects/mngrijal/proj/index.html">UCSC Page</a><br/><a href="http://classes.soe.ucsc.edu/cmps161/Winter14/projects/mngrijal/proj/writeup.pdf">Final Paper</a></th></tr></thead><tbody><tr><td><p>This is a project that took course over the entire quarter of a Data Visualization course. My project focused on observing connections between the amount of motion in a movie (i.e. amount of action), colors, and word frequency. The program I wrote (using OpenCV-Python) extracts this information directly from the video and subtitles file of the movie.<br/><br/>The exact nature of the project may be a bit fuzzy, so viewing the live demo is the best way to get a sense of what is going on. The words you see are the words that were spoken in that scene. Their size relates to how often they were used. The words are colored using the colors from the scene. The amount the words shift back-and-forth relates to how much motion was in the scene. You can choose different movies and look through each chapter using the controls at the top. Change the background color by clicking the white square.<br/><br/>The final paper link will direct you to the final paper that was required for the class. It will go through how the entire process works, bugs/issues, etc.<br/><br/>Automation was a large focus of this project, so the process of extracting data is almost completely automated. Visit the wiki on the Github repo for instructions on how to analyze your own collection of movies. Analyzing a movie usually took around an hour on a Pentium powered laptop.</p></td><td><a href="images/filmclouds_thumb.jpg"><img width="200px" src="images/filmclouds_thumb.jpg"/></a></td></tr></tbody></table><!-- Fork in the Read --><table class="table table-bordered table-custom"><thead><tr><th>Fork in the Read</th><th><a href="https://github.com/supreme-committee/text-adventure/releases">Download</a><br/><a href="https://github.com/supreme-committee/text-adventure">Github Repo</a></th></tr></thead><tbody><tr><td><p>This was a team project for a software engineering course. Over the course of ten weeks we designed a game engine for creating choose-your-own-adventure type games. Games are scripted via xml files. You can integrate images, music, and sounds into your game. It is also possible to define and modify variables as a player plays your game. Conditional (if and else) statements are supported so that you can control the flow of your game.<br/><br/>The download link contains a sample game as well as the user manual.<br/>Added 12/6/2013</p></td><td><a href="images/FITR_screenshot.png"><img width="200px" src="images/FITR_screenshot.png"/></a></td></tr></tbody></table><!-- Game of Hex --><table class="table table-bordered table-custom"><thead><tr><th>Game of Hex (C++)</th><th><a href="https://dl.dropboxusercontent.com/u/423071/mgrijalva%20Website%20Downloads/Game_of_Hex.zip">Download</a><br/><a href="https://github.com/mgrijalva/Game_of_Hex">Source Code</a></th></tr></thead><tbody><tr><td><p>This is a program of the board game Hex . The white player plays from the top to the bottom, and the black player plays from left to right. Each player tries to form a pathway across the board.<br/><br/>The AI uses the Monte Carlo method. While the method itself seems rather stupid, the results are surprisingly intelligent. The AI is tough to beat. The AI works best on board sizes of around 5 to 11. 11 is the standard size for Hex.<br/><br/>This game was initially written for a class, but I wasn't happy with its performance. I re-wrote it from scratch to increase performance by fixing design issues (I used pointers way too much) and adding C++11 threading.<br/><br/>NOTE: You can easily compile a Unix version with the Makefile on the Github page. The above download link contains a Windows version.</p></td><td><a href="images/gameofhex_screenshot.png"><img width="200px" src="images/gameofhex_screenshot.png"/></a></td></tr></tbody></table><!-- Game of Life --><table class="table table-bordered table-custom"><thead><tr><th>Game of Life (C)</th><th><a href="https://dl.dropbox.com/u/423071/mgrijalva%20Website%20Downloads/Program1%20-%20gameoflife.zip">Download (Unix version)</a></th></tr></thead><tbody><tr><td><p>This program is run via a UNIX command line. Run "gameoflife [FILE]" where FILE contains info about the creature to simulate. Some samples are included.<br/><br/>This program simulates the classic game of life. It prints a before and after picture containing the creature after the requested number of generations.<br/><br/>One issue with the game of life is how to count the neighbours efficiently. One could simply scan the entire array, count the neighbours, kill/create the appropriate cells, and be done. This is horribly (O(n^2)) inefficient though. The implementation in this program uses an un-initialized array.<br/><br/>The live cells are placed into an empty array separate from the main board. For each generation the program looks at this array, finds the neighbouring cells, counts the live neighbours for each one, kills/creates cells, adds the new live cells to the array, and removes the dead cells. Using this method only the live cells need to be checked for each generation. This brings the running time down to O(n), where n is the number of live cells.</p></td><td><a href="images/gameoflife_screenshot.png"><img width="200px" src="images/gameoflife_screenshot.png"/></a></td></tr></tbody></table><!-- Crossing Matchstick Game --><table class="table table-bordered table-custom"><thead><tr><th>Crossing Matchstick Game (Python)</th><th><a href="https://dl.dropbox.com/u/423071/mgrijalva%20Website%20Downloads/Program3%20-%20Matchstick%20Game.zip">Download</a></th></tr></thead><tbody><tr><td><p>The rules of the game are so: You must take a match and jump two matches to cross it with another. The goal is to end up with all the matches crossed. A video of the game can be seen here: <a target="_blank" href="http://www.youtube.com/watch?v=rsT2yWqRPf0">YouTube video</a><br/><br/>The program is run like any other Python program. i.e. “python Program3.py [FILE]” where FILE contains the configuration of sticks. The first line specifies how many. In the next line a 0 means uncrossed, and a 1 means two matchsticks crossed. The program will solve it and spit out a solution (in backwards order).<br/><br/>Hashing is used to increase the solving speed. With hashing (memoization) the same situation need not be solved over and over. A recursive solution was used first, and then hashing was used to introduce memoization. The new version of the program solved most game sizes around 17 times faster. With 20 sticks the game is solved in around 0.47 seconds with hashing and 143 seconds without. More of this info can be seen in the README file.</p></td><td><a href="images/matchstick_screenshot.png"><img width="200px" src="images/matchstick_screenshot.png"/></a></td></tr></tbody></table>			</div>
		</div>

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    	<script src="js/bootstrap.min.js"></script>
	</body>
</html>